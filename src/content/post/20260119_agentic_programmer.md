---
title: 'Agentic Programmer'
description: '문제 정의 능력과 실행 결과에 대한 책임을 동시에 갖춘 프로그래머로 성장하기'
pubDate: 'Jan 19 2026'
---

> '우리의 전문 분야는 특화되지 않는 것이다'

## 1. Agentic Programmer란

Agentic Programmer는 **문제 정의 능력**과 **실행 결과에 대한 책임**을 동시에 갖춘 프로그래머입니다.

우리의 차별화는 "무엇을 만들지"가 아닌 "**어떤 문제를 풀지 결정하고, 그 결과에 책임지는 것**"에 있습니다.

LLM이 혁신적으로 발전하고 있는 오늘 간단한 코드를 작성하는 것은 AI도 할 수 있습니다.

하지만 불확실한 상황에서 문제를 정의하고, 실행하고, 결과에 책임지는 것은 여전히 그리고 앞으로도 인간의 영역일 것입니다.

## 2. General Purpose Programming

엘리트 운동선수들을 생각해보세요. 마라톤 선수는 42km를 가장 빠르게 달립니다. 역도 선수는 가장 무거운 무게를 듭니다. 하지만 예측 불가능한 도전이 주어지면 어떨까요?

복합적인 체력을 훈련한 선수들이 빛을 발합니다. 그들은 마라톤 선수만큼 빠르지는 않지만 충분히 빠르고, 역도 선수만큼 강하지는 않지만 충분히 강합니다. 어떤 도전이 주어져도 대응할 수 있는 범용적 능력을 고루 갖추고 있습니다.

우리가 추구하는 Agentic Programmer도 비슷합니다. 특정 도메인에서 최고가 되기보다는, 대부분의 영역에서 충분히 뛰어난 엔지니어가 되는 것을 추구합니다.

단순히 여러 기술을 아는 제너럴리스트와는 다릅니다. 범용적 능력은 문제 유형 기반으로 명확한 기준이 있는 충분한 깊이를 갖춥니다. 넓지만 얕은 것이 아니라, 필요한 곳에서 필요한 깊이를 확보하고 있는 사람을 Agentic Programmer라고 부릅니다.

## 3. 왜 Agentic해야 하는가

우리는 커리어, 재정적 보상, 명예를 얻기 위해서 좋은 직장에 갑니다. 하지만 실제로 그런 곳에 가면 당신이 얻게 되는 것은 황금수갑(Golden Handcuffs) 뿐입니다. 아마 당신도 사람들이 좋아하는 직장에 가본 경험이 있다면 제 말이 무슨 의미인지 이해할 수 있을 겁니다.

당신이 아는 최고의 프로그래머들을 떠올려 보세요. 아마도 어떤 유명한 회사 "출신"일 것입니다. 현재는 그곳에 속해 있지 않겠죠. 그들은 자유로운 삶을 선택했습니다. 단지 회사 이름이 가진 후광에 기대지 않습니다. 그들은 실력과 결과물로 스스로를 증명합니다. 마치 Craftmanship을 지닌 장인처럼요.

이처럼 좋은 프로그래머는 여러분을 자유롭게 합니다. 이는 어디에서, 누구와, 무엇을 할지 선택권을 갖게 되는 것과 같습니다.

### AI 시대의 핵심 위협

코딩 자동화로 인해 프로그래머의 역할이 축소되고 있습니다. 코드를 작성하는 것만으로는 더 이상 차별화되지 않습니다.

생존 전략은 불확실한 문제를 정의하고 해결하는 능력으로 차별화하는 것입니다. AI는 여전히 문제를 정의하고 실행 결과에 책임질 수 없습니다. AI가 대체할 수 없는 영역에서 인간만이 할 수 있는 고유의 가치를 만들어야 합니다.

## 4. 이 가이드의 대상

이 가이드는 모든 프로그래머를 위한 것이 아닙니다. 이런 성향의 사람들을 위한 가이드입니다:

- **자율성을 중시하는 사람**: 누군가가 시키는 일보다 스스로 정의한 문제를 푸는 것을 선호
- **불확실성을 감내하는 사람**: 정해진 길보다 탐험을 선호하고, 실패 가능성을 수용할 수 있음
- **불편함을 감수하는 사람**: 성장을 위해 익숙하지 않은 영역에 뛰어들 준비가 됨

만약 안정적인 대기업 커리어를 원하고, 전문 분야 하나를 깊게 파고 싶다면, 이 가이드가 맞지 않을 수 있습니다. 그것도 훌륭한 선택입니다.

이 훈련 철학은 모든 문제에 어떠한 상상 가능한 과제와 도전에 잘 대응하는 "준비된 엔지니어링 역량"을 키우는 것이 Agentic Programmer로 성장할 수 있는 대상입니다.

## 5. Agentic Programmer의 3대 원칙

### 1) Adaptive Variance - 변수에 대한 적응

주변의 엔지니어들 중에는 한 가지 기술에 심취한 사람을 많이 볼 수 있습니다. 이런 사람들을 말하는 유명한 프로그래밍 세계의 격언이 있습니다. '망치를 든 사람에게는 모든 문제가 못으로 보인다'

매일 비슷한 기술 스택과 구조만 반복하면 전체적으로 유연하게 사고할 수 있는 균형이 무너집니다. 다양한 문제 해결을 훈련해야 어떤 상황에도 대응할 수 있는 엔지니어링 역량이 만들어집니다.

Agentic Programmer도 마찬가지입니다. 매일 다른 유형의 문제를 풉니다. 오늘은 프론트엔드, 내일은 API 설계, 모레는 시스템 아키텍처. 한 영역에 갇히지 않습니다.

### 2) Intentional Constraint - 의도적 제약

성장은 불편함에서 옵니다. 익숙한 환경에서 익숙한 방식으로 코드를 작성하는 것은 "일"이지 "훈련"이 아닙니다.

Agentic Programmer는 스스로에게 제약을 겁니다:
- **시간 제약**: "2시간 안에 동작하는 프로토타입"
- **도구 제약**: "평소 안 쓰던 언어/프레임워크로"
- **범위 제약**: "End-to-end로 배포까지"

제약은 창의성을 죽이는 것이 아닙니다. 제약은 진짜 실력을 드러내고, 약점을 발견하게 합니다.

면접에서 45분 안에 문제를 풀어야 할 때, 장애 상황에서 30분 안에 원인을 찾아야 할 때, 당신은 "준비된 상태"여야 합니다.

### 3) Delivered Value - 전달된 가치

알고리즘 문제 100개를 푸는 것과 한 명의 사용자가 쓰는 서비스를 만드는 것은 다릅니다.

Agentic Programmer의 훈련은 반드시 "전달"로 끝납니다:
- 누군가가 실행할 수 있는 것
- 누군가가 피드백을 줄 수 있는 것
- 누군가의 문제가 실제로 해결되는 것

"완벽해지면 공개하겠다"는 함정입니다. 불완전해도 전달하고, 피드백 받고, 개선하는 사이클이 실력을 가장 빠르게 키웁니다.

GitHub에 올리세요. 블로그에 쓰세요. 누군가에게 보여주세요. **전달되지 않은 가치는 가치가 아닙니다.**
